\chapter{Model of Inference}
\begin{figure}[h]
\begin{lstlisting}[language=Coq]
Lemma inferFrom_iff_inferrable : forall m st,
  inferFrom m = st <-> inferrable m st.
Proof.
  intros m st; split; intros H.
  - generalize dependent m; assert (HI : forall m, inferrable m (inferFrom m)); intros m.
  -- induction m; simpl; try destruct c; try destruct s; 
     repeat constructor; assumption.
  -- intros H; induction m; subst; apply HI.
  - induction H; simpl; subst; try destruct cert; reflexivity.
Qed.
\end{lstlisting}
\end{figure}



\begin{figure}[h]
\begin{lstlisting}[language=Coq]
Fixpoint inferFrom (msg : message) : state :=
  match msg with
  | signature m k => 
      (signature m k :: inferFrom m)
  | TPM2B_Attest k => 
      [TPM2B_Attest k ; publicKey k]
  | TCG_CSR_IDevID id' (Cert k id k_ca) k' => 
      [TCG_CSR_IDevID id' (Cert k id k_ca) k' ; publicKey k' ; 
       signedCertificate (Cert k id k_ca) ; publicKey k]
  | TCG_CSR_LDevID m (Cert k id k_ca) => 
      (TCG_CSR_LDevID m (Cert k id k_ca) :: inferFrom m ++ 
      [signedCertificate (Cert k id k_ca) ; publicKey k])
  | signedCertificate (Cert k id k_ca) => 
      [signedCertificate (Cert k id k_ca) ; publicKey k]
  | pair m1 m2 => 
      (pair m1 m2 :: inferFrom m1 ++ inferFrom m2)
  | _ => 
      [msg]
  end.

  \end{lstlisting}
  \end{figure}



\begin{figure}[h]
\begin{lstlisting}[language=Coq]
Inductive inferrable : message -> state -> Prop :=
| I_publicKey : forall k,
    inferrable (publicKey k)
                [publicKey k]
| I_privateKey : forall k,
    inferrable (privateKey k)
                [privateKey k]
| I_hash : forall m,
    inferrable (hash m)
                [hash m]
| I_signature : forall m k st,
    inferrable m st ->
    inferrable (signature m k)
                (signature m k :: st)
| I_Attest : forall k,
    inferrable (TPM2B_Attest k)
                [TPM2B_Attest k ; publicKey k]
| I_encryptedCredential : forall n g k,
    inferrable (encryptedCredential n g k)
                [encryptedCredential n g k]
| I_randomNum : forall g,
    inferrable (randomNum g)
                [randomNum g]
| I_CSR_IDevID : forall id' cert k' st,
    inferrable (signedCertificate cert) st ->
    inferrable (TCG_CSR_IDevID id' cert k')
                (TCG_CSR_IDevID id' cert k' :: publicKey k' :: st)
| I_CSR_LDevID : forall m cert st1 st2,
    inferrable m st1 ->
    inferrable (signedCertificate cert) st2 ->
    inferrable (TCG_CSR_LDevID m cert) 
                (TCG_CSR_LDevID m cert :: st1 ++ st2)
| I_signedCertificate : forall k id k_ca,
    inferrable (signedCertificate (Cert k id k_ca)) 
                [signedCertificate (Cert k id k_ca) ; publicKey k]
| I_pair : forall m1 m2 st1 st2,
    inferrable m1 st1 ->
    inferrable m2 st2 -> 
    inferrable (pair m1 m2) 
                (pair m1 m2 :: st1 ++ st2).
\end{lstlisting}
\end{figure}

