\chapter{Theroems on Sequential Execution}


\begin{figure}[h]
\begin{lstlisting}[language=Coq]
Theorem seq_exec_deterministic : forall ini s fin1 fin2,
  seq_execute ini s fin1 ->
  seq_execute ini s fin2 ->
  fin1 = fin2.
Proof.
  intros ini s fin1 fin2 E1 E2; generalize dependent fin2;
  induction E1; intros fin2 E2; inversion E2; subst.
  - assert (mid = mid0) as EQ_mid;
    [ apply exec_deterministic with (ini := ini) (c := c)
    | apply IHE1; rewrite <- EQ_mid in H5 ]; assumption.
  - reflexivity.
Qed.

Theorem seq_exec_expansion : forall iniTPM ini s finTPM fin,
  seq_execute (iniTPM,ini) s (finTPM,fin) ->
  (iniTPM \subsetOf finTPM) /\ (ini \subsetOf fin).
Proof.
  intros iniTPM ini s finTPM fin E; split;
  generalize dependent fin; generalize dependent finTPM;
  generalize dependent ini; generalize dependent iniTPM;
  induction s; intros;
  inversion E; subst; try (intros m' I; assumption);
  destruct mid as [midTPM mid];
  assert (Inc : (iniTPM \subsetOf midTPM) /\ (ini \subsetOf mid)); 
  try (apply exec_expansion with (c := c); assumption).
  - apply Included_transitive with (st2 := midTPM);
    [ apply Inc
    | apply IHs with (ini := mid) (fin := fin); assumption ].
  - apply Included_transitive with (st2 := mid);
    [ apply Inc
    | apply IHs with (iniTPM := midTPM) (finTPM := finTPM); assumption ].
Qed.
\end{lstlisting}
\end{figure}

\begin{figure}[h]
\begin{lstlisting}[language=Coq]
Theorem seq_exec_cannotGenerateKey : forall s iniTPM ini finTPM fin k,
  seq_execute (iniTPM, ini) s (finTPM, fin) ->
  In (privateKey k) finTPM ->
  In (privateKey k) iniTPM.
Proof.
  induction s; intros iniTPM ini finTPM fin k E I;
  inversion E; subst; try assumption; destruct mid as [midTPM mid];
  eapply exec_cannotGenerateKey; eauto.
Qed.

Theorem seq_exec_cannotGenerateRand_contrapositive : forall s iniTPM ini finTPM fin g,
  seq_execute (iniTPM, ini) s (finTPM, fin) ->
  ~ In (randomNum g) ini ->
  (forall n k, ~ In (encryptedCredential n g k) ini) ->
  ~ In (randomNum g) fin.
Proof.
  induction s; intros iniTPM ini finTPM fin g E Ng N.
  - destruct c; inversion E; inversion H2; 
    subst; eapply IHs; try fdeq;
    try (intros n0 k HC; inversion HC; try congruence; destruct (N n0 k); assumption);
    intros HC; inversion HC;
    [ inversion H; subst; destruct (N n (Public i r s1 d f)); assumption
    | congruence ].
  - inversion E; subst; congruence.
Qed.

Theorem seq_exec_cannotGenerateCred_contrapositive : forall s iniTPM ini finTPM fin n g k,
  seq_execute (iniTPM, ini) s (finTPM, fin) ->
  (forall n k, ~ In (encryptedCredential n g k) ini) ->
  ~ In (randomNum g) ini ->
  ~ In (encryptedCredential n g k) fin.
Proof.
  induction s; intros iniTPM ini finTPM fin n g k E Ne N;
  inversion E; subst; 
  [ destruct mid as [midTPM mid]; eapply IHs; eauto
  | intros HC; destruct (Ne n k); assumption];
  [ intros n0 k0; eapply exec_cannotGenerateCred_contrapositive; eauto
  | eapply exec_cannotGenerateRand_contrapositive; eauto].
Qed.
\end{lstlisting}
\end{figure}

\begin{figure}[h]
\begin{lstlisting}[language=Coq]
Lemma exec_deterministic : forall ini c fin1 fin2,
  execute ini c fin1 ->
  execute ini c fin2 ->
  fin1 = fin2.
Proof.
  intros ini c fin1 fin2 E1 E2;
  destruct E1; inversion E2; subst; reflexivity.
Qed.

Lemma exec_expansion : forall iniTPM ini c finTPM fin,
  execute (iniTPM,ini) c (finTPM,fin) ->
  (iniTPM \subsetOf finTPM) /\
  (ini \subsetOf fin).
Proof.
  intros iniTPM ini c finTPM fin E; split;
  destruct c; inversion E; subst; 
  intros m' I; try (repeat apply in_cons); assumption.
Qed.

Lemma exec_cannotGenerateKey : forall c iniTPM ini finTPM fin k,
  execute (iniTPM, ini) c (finTPM, fin) ->
  In (privateKey k) finTPM ->
  In (privateKey k) iniTPM.
Proof.
  destruct c; intros iniTPM ini finTPM fin k E I;
  inversion E; subst; try inversion I as [EQ_false | I']; 
  try inversion EQ_false; assumption.
Qed.

Lemma exec_cannotGenerateRand_contrapositive : forall c iniTPM ini finTPM fin g,
  execute (iniTPM, ini) c (finTPM, fin) ->
  ~ In (randomNum g) ini ->
  (forall n k, ~ In (encryptedCredential n g k) ini) ->
  ~ In (randomNum g) fin.
Proof.
  induction c; intros iniTPM ini finTPM fin g E Ng N;
  inversion E; subst; try assumption;
  intros HC; inversion HC; try inversion H; subst; try congruence;
  destruct (N n (Public i r s d f)); assumption.
Qed.

Lemma exec_cannotGenerateCred_contrapositive : forall c iniTPM ini finTPM fin n g k,
  execute (iniTPM, ini) c (finTPM, fin) ->
  ~ In (encryptedCredential n g k) ini ->
  ~ In (randomNum g) ini ->
  ~ In (encryptedCredential n g k) fin.
Proof.
  induction c;  intros iniTPM ini finTPM fin n g k E Ne N;
  inversion E; subst; try assumption;
  intros HC; inversion HC; try inversion H; congruence.
Qed.
\end{lstlisting}
\end{figure}   
 