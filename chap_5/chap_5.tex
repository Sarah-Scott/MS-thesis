\chapter{Identity Provisioning}

To mantain a cryptographic evidentiary chain linking a DevID to a specific TPM and device, the CA should follow certain provisioning protocols. The TCG describes several such protocols in their specification \textit{TPM 2.0 Keys for Device Identity and Attestation}. We will consider in detail two of these protocols: OEM creation of an IAK certificate based on an EK certificate and Owner/Administrator creation of an LAK certificate based on an IAK certificate. We choose these two protocols since they bear the most significance in enrollment of additional DevIDs (recall that AK certificates may be used as parent nodes in a chain of certificates). For each protocol, the TCG's specification not only outlines its steps but also claims it provides certain assurances.

For convenience and clarity, we will inspect each of these protocols in the reverse order that their dependencies entails.

\section{Owner/Administrator Creation of LAK Certificate based on IAK Certificate}
In this section, we will shorten the term Owner/Administrator to Owner. The Administrator may still be a participant in this protocol. We only mean for this to act as an abbreviation. Now, we begin by provided a description of the recommended procedure. 
\begin{enumerate}[itemsep=0pt,parsep=0pt,partopsep=0pt]
  \setcounter{enumi}{-1}
  \item The Owner creates and loads the LAK
  \item The Owner certifies the LAK with the IAK
  \item The Owner builds the CSR containing:
  \begin{enumerate}[topsep=0pt, itemsep=0pt,parsep=0pt,partopsep=0pt]
    \item The signed \verb|TPM2B_Attest| structure
    \item The IAK certificate
  \end{enumerate}
  \item The Owner takes a signature hash of the CSR
  \item The Owner signs the resulting hash digest with the LAK
  \item The Owner sends the CSR paired with the signed hash to the CA
  \item The CA verifies the recieved data by checking:
  \begin{enumerate}[topsep=0pt, itemsep=0pt,parsep=0pt,partopsep=0pt]
    \item The hash digest against the CSR
    \item The signature on the hash digest with the LAK public key
    \item The signature on the \verb|TPM2B_Attest| structure with the IAK public key
    \item The signature on the IAK certificate with the public key of the OEM's CA
    \item The attributes of the LAK
  \end{enumerate}
  \item If all of the checks succeed, the CA issues the LAK certificate to the Owner
\end{enumerate}
The TCG's specification claims that this procedure provides the following assurances: (A) the new LAK is resident in the same TPM as the IAK and (B) the LAK has the correct key properties. No proof or clear justification is presented to support this claim though. Our goal is to prove that these assurances do in fact hold. 

We model this protocol within Coq's \verb|Module Type| mechanism. This mechanisms allows for the inclusion of parameters which provides the necessary flexibility to describe the protocol generally. Each participating entity has its own parameters. The Owner has a key to be certified (i.e., the LAK), its IAK, and IAK certificate. The CA has its own key and the public key of the OEM's CA. The \verb|Module Type| mechanism additionally allows for axioms to be defined. When instantiating a Module Type with concrete values, one must prove all of the axioms. The first axiom we define is straightforward and only attempts to enforce the randomness of cryptographic keys, that is, all key parameters must be pairwise distinct.
\begin{figure}[h]
\begin{lstlisting}[language=Coq]
(* Owner parameters *)
Parameter pubLAK : pubKey.
Parameter pubIAK : pubKey.
Parameter certIAK : signedCert.

(* CA parameters *)
Parameter pubCA : pubKey.
Parameter pubOEM : pubKey.

(* All keys are pairwise distinct *)
Axiom keys_distinct :
  pubLAK <> pubIAK /\
  pubLAK <> pubCA /\
  pubLAK <> pubOEM /\
  pubIAK <> pubCA /\
  pubIAK <> pubOEM /\
  pubCA <> pubOEM.
\end{lstlisting}
\caption{Parameters of LAK Certification Protocol}
\end{figure}


 The procedure may be regarded as the composition of two sequences: the Owner's steps (i.e., steps 0-5) followed by the CA's steps (i.e., steps 6-7). With that in mind, we can construct an object of type \verb|sequence| for the Owner. Since the \verb|command| type does not include a method for creating and loading keys, we assume step 0 to have been performed prior to the sequence. 
\begin{figure}[h]
\begin{lstlisting}[language=Coq]
Definition steps1to5_Owner : sequence :=
TPM2_Certify 
   pubLAK 
   privIAK ;;
MakeCSR_LDevID 
  (signature (TPM2B_Attest pubLAK) privIAK) 
   certIAK ;;
TPM2_Hash 
  (TCG_CSR_LDevID (signature (TPM2B_Attest pubLAK) privIAK) certIAK) ;;
TPM2_Sign 
  (hash (TCG_CSR_LDevID (signature (TPM2B_Attest pubLAK) privIAK) certIAK)) 
   privLAK ;;
MakePair 
  (TCG_CSR_LDevID (signature (TPM2B_Attest pubLAK) privIAK) certIAK) 
  (signature (hash (TCG_CSR_LDevID (signature (TPM2B_Attest pubLAK) privIAK) certIAK)) privLAK) ;;
Done. 
\end{lstlisting}
\caption{Model of Correct Steps of Owner}
\end{figure}
The CA's steps are more complicated and are constructed as a function type. First the CA waits to recieve a certification request from the Owner (see the message paramter \verb|msg|). The request must be in a specific format to be considered valid (see the match statement on \verb|msg|). The CA then executes step 6 of the procedure (see the sequence within \verb|seq_execute|). If execution succeeds, the CA will issue the LAK certificate to the Owner (see the \verb|Prop| return type). We include several additional parameters and criteria to serve as a method for referencing certain elements of the certification request within proof statements.
\begin{figure}[h]
\begin{lstlisting}[language=Coq]
Definition steps_CA (msg : message) (iak lak : pubKey) (cert : signedCert) : Prop :=
  match msg with
  | (pair (TCG_CSR_LDevID (signature (TPM2B_Attest k) k0') 
                          (Cert k0 id k_ca'))
          (signature m k')) =>
        iak = k0 /\
        lak = k /\
        cert = (Cert k0 id k_ca') /\
        seq_execute (iniTPM_CA, inferFrom m ++ ini_CA)
                          (CheckHash m
                                    (TCG_CSR_LDevID (signature (TPM2B_Attest k) k0') 
                                                    (Cert k0 id k_ca')) ;;
                          CheckSig (signature m k') k ;;
                          CheckSig (signature (TPM2B_Attest k) k0') k0 ;;
                          CheckCert (Cert k0 id k_ca') pubOEM ;;
                          CheckAttributes k Restricting Signing NonDecrypting ;;
                          Done)
                          (iniTPM_CA, 
                          inferFrom m ++ ini_CA)
  | _ => False
  end.
\end{lstlisting}
\caption{Model of Correct Steps of Owner's CA}
\end{figure}


Going forward, we will consider two cases: (1) the Owner and the CA are both trusted to execute their steps correctly and (2) only the CA is trusted to execute its steps correctly. The TCG's specification does not state which of these assumptions they reason under. 

Let us first consider case 1: the Owner and the CA are both trusted to execute their steps correctly. We will begin by examining the Owner's steps and its requirements. We can quantitatively describe these requirements by a minimal initial state pair. Given a sequence, a minimal initial state pair is defined as the smallest TPM state and general state which allows for successful execution of the sequence. Note that this definition does not constrain the general state to be a superset of the TPM state; in fact, it is the case that for most sequences it is not. We intuitively construct a minimal initial state pair for \verb|steps1to5_Owner|. First, the private LAK and private IAK must reside in the same TPM because the Owner certifies the LAK with the IAK. Next, the IAK certificate must be in state because the Owner includes it in the CSR. This intuition is useful in proving that this resulting state pair is in fact minimal. The proof statement is constructed by two parts. First, the minimal initial state is a lower bound on the set of possible initial states. And second, the minimal initial state is sufficient for successful execution.



%A minimal initial state for the Owner can be constructed intuitively based on this sequence. In particular, given a sequence, a minimal initial state is defined as the smallest possible TPM state and general state which allows for successful execution of the sequence. Note that this definition does not constrain the general state to be a superset of the TPM state; in fact, it is the case that most often it is not. We provide a candidate initial state which satisfies this minimality constraint for the Owner's steps. The intuition behind choosing this candidate proceeds as follows. First, the private LAK and private IAK must reside in the same TPM because the Owner certifies the LAK with the IAK. Next, the IAK certificate must be in state because the Owner includes it in the CSR. The intuition behind building the minimal initial state is useful in proving that it is in fact minimal. The proof statement is constructed by two parts. First, the minimal initial state is a lower bound on the set of possible initial states. And second, the minimal initial state is sufficient for successful execution.
\begin{figure}[h]
\begin{lstlisting}[language=Coq]
Definition iniTPM_Owner : tpm_state :=
[ privateKey privLAK ;
  privateKey privIAK ].

Definition ini_Owner : state :=
[ signedCertificate certIAK ].

Lemma ini_Owner_lowerBound : forall iniTPM ini fin,
  seq_execute (iniTPM, ini) steps1to5_Owner fin ->
  (iniTPM_Owner \subsetOf iniTPM) /\
  (ini_Owner \subsetOf ini).

Lemma ini_Owner_sufficient : forall m,
  attestationKey pubIAK ->
  steps_CA m pubIAK pubLAK certIAK ->
  exists fin, seq_execute (iniTPM_Owner, ini_Owner) steps1to5_Owner fin.
\end{lstlisting}
\caption{Minimal Initial State of Owner}
\end{figure}
The lower bound property is proven to hold in general. On the other hand, the sufficiency property requires that the IAK and LAK have "good" attributes. Specifically both keys must have the \verb|Sign| attribute set in order to execute the \verb|TPM2_Certify| and \verb|TPM2_Sign| commands respectively. We choose to make the broader assumption that the IAK and LAK have all of the attributes associated with a good attestation key. See Appendix x for the proofs of these two statements.






\newpage
\section{OEM Creation of IAK Certificate based on EK Certificate}

\begin{enumerate}[itemsep=0pt,parsep=0pt,partopsep=0pt]
  \setcounter{enumi}{-1}
  \item The OEM creates and loads the IAK
  \item The OEM builds the CSR containing:
  \begin{enumerate}[topsep=0pt, itemsep=0pt,parsep=0pt,partopsep=0pt]
    \item Device identity information including the device model and serial
    number
    \item The EK certificate
    \item The IAK public area
  \end{enumerate}
  \item The OEM takes a signature hash of the CSR
  \item The OEM signs the resulting hash digest with the IAK
  \item The OEM sends the CSR paired with the signed hash to the CA
  \item The CA verifies the recieved data by checking:
  \begin{enumerate}[topsep=0pt, itemsep=0pt,parsep=0pt,partopsep=0pt]
    \item The hash digest against the CSR
    \item The signature on the hash digest with the IAK public key
    \item The signature on the EK certificate with the public key of the TPM Manufacturer's CA
    \item The attributes of the IAK
  \end{enumerate}
  \item If all of the checks succeed, the CA issues a challenge blob to the OEM by:
  \begin{enumerate}[topsep=0pt, itemsep=0pt,parsep=0pt,partopsep=0pt]
    \item Calculating the cryptographic name of the IAK
    \item Generating a nonce
    \item Building the encrypted credential structure using the name of the IAK, the nonce, and the EK public key
  \end{enumerate}
  \item The OEM releases the secret nonce by verifying the name of the IAK and decrypting the challenge blob
  \item The CA checks the returned nonce against the one generated in step 6b
  \item If the check succeeds, the CA issues the IAK certificate to the OEM
\end{enumerate}

We model this protocol within Coq's \verb|Module Type| mechanism. This mechanisms allows for the inclusion of parameters which provides the necessary flexibility to describe the protocol in the general case. Each participating entity has its own parameters. The OEM has a key to be certified (i.e., the IAK), its EK certificate, and information to identify its device. The CA has its own key, the public key of the TPM Manufacturer's CA, and a nonce. The nonce parameter may be removed if we include the \verb|TPM2_GetRandom| command in the model's language. The \verb|Module Type| mechanism additionally allows for axioms to be defined. When instantiated a Module Type with concrete values, one must prove all of the axioms. The first axiom we define is straightforward and only attempts to enforce the randomness of cryptographic keys, that is, all key parameters must be pairwise distinct.





